---
sidebar_position: 3
title: Lesson 2.3 - Robot Control and Dynamics
---

# Lesson 2.3: Robot Control and Dynamics

**Duration**: ~3 hours | **Pages**: 20 | **Difficulty**: Intermediate

## Learning Objectives

By the end of this lesson, you will:
- ‚úÖ Implement joint control (effort, velocity, position)
- ‚úÖ Apply PID controllers for smooth motion
- ‚úÖ Tune control gains for stable behavior
- ‚úÖ Execute trajectories in simulation
- ‚úÖ Monitor joint forces and torques
- ‚úÖ Validate control before hardware deployment

---

## üéØ Joint Control Types

### 1. Effort Control (Force/Torque)

```xml
<joint name="shoulder_joint" type="revolute">
  <parent link="base"/>
  <child link="arm_link"/>
  <axis xyz="0 1 0"/>
  <limit lower="-1.57" upper="1.57" effort="50" velocity="1.0"/>
  <dynamics damping="0.01" friction="0.01"/>
</joint>
```

```python
from gazebo_msgs.srv import ApplyJointEffort
import rclpy

class JointController(rclpy.node.Node):
    def __init__(self):
        super().__init__('joint_controller')
        self.client = self.create_client(ApplyJointEffort, '/apply_joint_effort')

    def apply_torque(self, joint_name, effort):
        req = ApplyJointEffort.Request()
        req.joint_name = joint_name
        req.effort = effort  # N‚ãÖm
        req.duration = rclpy.duration.Duration(seconds=1)
        self.client.call_async(req)

# Usage: controller.apply_torque('shoulder_joint', 10.0)  # 10 N‚ãÖm
```

### 2. Velocity Control

```xml
<plugin name="gazebo_ros_joint_state_publisher" filename="libgazebo_ros_joint_state_publisher.so">
  <ros>
    <remapping>~/joint_states:=/joint_states</remapping>
  </ros>
  <update_rate>100</update_rate>
</plugin>
```

```python
from std_msgs.msg import Float64MultiArray

class VelocityController(rclpy.node.Node):
    def __init__(self):
        super().__init__('velocity_controller')
        self.pub = self.create_publisher(
            Float64MultiArray,
            '/joint_controller/command',
            10
        )
        self.create_timer(0.01, self.send_command)

    def send_command(self):
        msg = Float64MultiArray()
        msg.data = [0.5, -0.3, 0.2]  # rad/s for 3 joints
        self.pub.publish(msg)
```

### 3. Position Control (Trajectory)

```python
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
import math

class TrajectoryController(rclpy.node.Node):
    def __init__(self):
        super().__init__('trajectory_controller')
        self.pub = self.create_publisher(
            JointTrajectory,
            '/joint_trajectory_controller/command',
            10
        )

    def execute_trajectory(self, target_position, duration=2.0):
        traj = JointTrajectory()
        traj.joint_names = ['shoulder', 'elbow', 'wrist']

        # Single point trajectory
        point = JointTrajectoryPoint()
        point.positions = target_position
        point.velocities = [0.0, 0.0, 0.0]
        point.time_from_start = rclpy.duration.Duration(seconds=duration)

        traj.points = [point]
        self.pub.publish(traj)

# Usage: controller.execute_trajectory([0.5, 0.3, -0.2], duration=2.0)
```

---

## üéõÔ∏è PID Control Loop

### PID Tuning

```python
class PIDController:
    def __init__(self, kp=1.0, ki=0.0, kd=0.1):
        self.kp = kp  # Proportional gain
        self.ki = ki  # Integral gain
        self.kd = kd  # Derivative gain

        self.error_integral = 0
        self.error_prev = 0

    def update(self, error, dt):
        # Proportional term
        p_term = self.kp * error

        # Integral term (accumulate error over time)
        self.error_integral += error * dt
        i_term = self.ki * self.error_integral

        # Derivative term (rate of error change)
        d_term = self.kd * (error - self.error_prev) / dt
        self.error_prev = error

        # Total output
        output = p_term + i_term + d_term
        return output

# Usage
pid = PIDController(kp=10.0, ki=1.0, kd=0.5)
target = 1.5  # radians
current = 0.0

for _ in range(100):
    error = target - current
    control_effort = pid.update(error, dt=0.01)
    current += control_effort * 0.01  # Simulate motion
    print(f'Position: {current:.3f}, Error: {error:.3f}')
```

### Tuning Guidelines

| Gain | Effect | Increase | Decrease |
|------|--------|----------|----------|
| **Kp** | Speed to target | Faster response | Oscillation |
| **Ki** | Steady-state error | Removes offset | Slow oscillations |
| **Kd** | Damping | Smooth motion | Sluggish response |

---

## üìä Monitoring Joint State

```python
from sensor_msgs.msg import JointState
import numpy as np

class JointMonitor(rclpy.node.Node):
    def __init__(self):
        super().__init__('joint_monitor')
        self.subscription = self.create_subscription(
            JointState,
            '/joint_states',
            self.state_callback,
            10
        )
        self.positions = {}
        self.velocities = {}
        self.efforts = {}

    def state_callback(self, msg):
        for i, name in enumerate(msg.name):
            self.positions[name] = msg.position[i]
            self.velocities[name] = msg.velocity[i]
            if i < len(msg.effort):
                self.efforts[name] = msg.effort[i]

    def log_state(self):
        for joint_name in self.positions.keys():
            self.get_logger().info(
                f'{joint_name}: '
                f'pos={self.positions[joint_name]:.3f} rad, '
                f'vel={self.velocities[joint_name]:.3f} rad/s, '
                f'eff={self.efforts.get(joint_name, 0):.3f} N‚ãÖm'
            )
```

---

## üîç Control Validation

### Performance Metrics

```python
class ControlValidator:
    def __init__(self, target, tolerance=0.01):
        self.target = target
        self.tolerance = tolerance
        self.errors = []
        self.overshoots = 0
        self.settling_time = 0

    def evaluate(self, current_position, time):
        error = self.target - current_position
        self.errors.append(abs(error))

        # Detect overshoot
        if abs(current_position) > abs(self.target) + 0.1:
            self.overshoots += 1

        # Settling time: when error enters tolerance band
        if abs(error) < self.tolerance and self.settling_time == 0:
            self.settling_time = time

    def get_metrics(self):
        return {
            'steady_state_error': self.errors[-1] if self.errors else 0,
            'max_error': max(self.errors) if self.errors else 0,
            'mean_error': np.mean(self.errors) if self.errors else 0,
            'overshoots': self.overshoots,
            'settling_time': self.settling_time,
        }
```

---

## üöÄ Best Practices

1. **Start with low gains**: Increase Kp gradually
2. **Monitor for oscillations**: Sign of excessive gain
3. **Use velocity limits**: Prevent jerky movements
4. **Filter accelerations**: Reduce shock loads
5. **Validate in simulation first**: Before hardware
6. **Log everything**: Debug if hardware fails

---

**Next**: [Module 2 Exercises](exercises-2.mdx)
